import React, { useState, useCallback, useMemo } from 'react';
import TopicViewer from "./TopicViewer"
import './TopicsList.css';


const topics = [
  {
    title: 'Работа с числами',
    content: `Работа с числами в ассемблере включает выполнение различных арифметических операций, таких как сложение, вычитание, умножение и деление. Эти операции выполняются с использованием специальных машинных инструкций и регистров процессора.
      Основные арифметические операции:
      Сложение (ADD): Команда ADD используется для сложения двух чисел. Она складывает значение операнда с содержимым регистра и сохраняет результат в регистре.
      Вычитание (SUB): Команда SUB используется для вычитания одного числа из другого. Она вычитает значение операнда из содержимого регистра и сохраняет результат в регистре.
      Пример:
      MOV AX, 4  ; Переместить значение 4 в регистр AX
      ADD AX, 3  ; Добавить значение 3 к содержимому регистра AX, в результате AX будет содержать 7
      SUB AX, 1  ; Вычесть 1 из содержимого регистра AX, в результате AX будет содержать 6`
  },
  {
    title: 'Работа процессора',
    content: `В этом разделе мы рассмотрим ключевые компоненты, составляющие внутреннюю архитектуру процессоров, таких как те, что разрабатываются Intel. Эти элементы играют критическую роль в выполнении вычислительных задач и обеспечивают высокую производительность современных компьютеров.

    1. Арифметико-Логическое Устройство (ALU)
       - ALU является центральным компонентом процессора, ответственным за выполнение всех арифметических и логических операций.
       - Основные функции ALU включают сложение, вычитание, умножение, деление, а также выполнение логических операций, таких как AND, OR, XOR и NOT.
       - ALU принимает операнды (входные данные) из регистров, выполняет вычисления и возвращает результат обратно в регистры или в память.`
  },
  {
    title: 'Синтаксис Ассемблера',
    content: `Ассемблер является языком низкого уровня, который напрямую соответствует инструкциям процессора. Основные концепции ассемблера включают:
  Мнемоники
  Мнемоники (или мнемонические коды) — это символические имена для машинных инструкций, которые облегчают чтение и написание кода. Вместо того чтобы писать длинные и сложные бинарные или шестнадцатеричные коды, программисты используют понятные обозначения.
    
  Пример:
  MOV AX, 1    ; Переместить значение 1 в регистр AX
  ADD AX, 2    ; Добавить 2 к значению в регистре AX
  SUB AX, 1    ; Вычесть 1 из значения в регистре AX
    
    В этом примере MOV, ADD и SUB являются мнемониками, которые представляют машинные команды для перемещения данных и выполнения арифметических операций[5].
    
    Регистр
    Регистры — это небольшие, высокоскоростные хранилища данных в процессоре. Программы на ассемблере работают с регистрами процессора для выполнения различных операций.
    Основные регистры в архитектуре x86:
    AX (Accumulator): используется для арифметических операций и ввода/вывода.
    BX (Base): часто используется для индексирования.
    CX (Count): используется для счетчиков в циклах.
    DX (Data): используется для ввода/вывода и некоторых операций умножения и деления.
    Пример:
    MOV AX, 5    ; Переместить значение 5 в регистр AX
    MOV BX, AX   ; Скопировать значение из регистра AX в регистр BX
    В этом примере значение 5 сначала загружается в регистр AX, а затем копируется в регистр BX[6].
    
    Адресация
    Ассемблер предоставляет различные методы адресации, которые определяют, как операнды выбираются для команд. Основные методы адресации включают:
    
    Непосредственная адресация: значение операнда указывается непосредственно.
    Регистровая адресация: операнд находится в регистре.
    Косвенная адресация: операнд находится по адресу, который содержится в регистре.
    Пример:
    
    MOV AX, 10       ; Непосредственная адресация: переместить значение 10 в AX
    MOV BX, AX       ; Регистровая адресация: переместить значение из AX в BX
    MOV CX, [BX]     ; Косвенная адресация: переместить значение из памяти по адресу BX в CX
    В этом примере используются разные методы адресации для работы с регистрами и памятью.
    
    Директивы
    Директивы в ассемблере управляют процессом сборки программы. Они не являются командами для процессора, но дают указания ассемблеру, как обрабатывать код.
    
    
    Основные директивы:
    
    SEGMENT: определяет начало сегмента.
    ENDS: указывает конец сегмента.
    DB (Define Byte): определяет байт данных.
    Пример:
    
    DATA SEGMENT
           NUM1 DB 10      ; Определить байт данных со значением 10
            NUM2 DB 20      ; Определить байт данных со значением 20
    DATA ENDS
    
    CODE SEGMENT
            ASSUME CS:CODE, DS:DATA
    START:
           MOV AX, DATA
           MOV DS, AX
            MOV AL, NUM1    ; Переместить значение NUM1 в AL
           MOV BL, NUM2    ; Переместить значение NUM2 в BL
           ADD AL, BL      ; Сложить значения в AL и BL
            MOV NUM1, AL    ; Сохранить результат обратно в NUM1
            INT 20H         ; Завершить программу
    CODE ENDS
    END START
    
    В этом примере используются директивы для определения сегментов данных и кода, а также для управления сборкой программы[8].
    
    
    
    
    Комментарии
    Комментарии в ассемблере используются для объяснения кода и улучшения его читаемости. Комментарии начинаются с символа “;” и игнорируются ассемблером при сборке программы.
    
    Пример:
    MOV AX, 1    ; Переместить значение 1 в регистр AX
    ADD AX, 2    ; Добавить 2 к значению в регистре AX
    SUB AX, 1    ; Вычесть 1 из значения в регистре AX
    В этом примере комментарии объясняют каждую команду, делая код более понятным для других программистов[9].
    `
  },
  {
    title: 'Краткие теоретические сведения для Лабораторной работы №1',
    content: `Микропроцессор Intel семейства P6 содержит восемь регистров общего назначения (РОН), которые используются для хранения операндов и результатов команд, а также для формирования адреса при обращении к данным в памяти.
    РОН микропроцессора Intel P6, их разрядность и вложенность приведены в таблице 2.
     
    
    Таблица 2.
    31	16	15	8	7	0	← номера битов
    EAX EBX ECX EDX EBP ESI EDI
    ESP
    При обращении к ячейкам памяти, адрес ячейки памяти может указываться косвенно, т.е. адрес может быть указан в каком-либо РОН или с помощью математического выражения следующего вида:
    
    
    
     
    Первое слагаемое называется базой, второе – индекс, умноженный на масштаб, третье – константа. Формула может состоять из любого сочетания слагаемых в квадратных скобках (напомним, что в квадратных скобках здесь указаны слагаемые, которые могут полностью отсутствовать) и любого элемента из каждой строчки в круглых скобках. Следует напомнить, что операнд, задающий адрес ячейки памяти, указывается в квадратных скобках.
    Все команды на языке ассемблера записываются в виде мнемоники команды и разного количества операндов. Мнемоника — это сокращение английских слов, выражающих смысл команды.
    К командам пересылки данных относятся:
    MOV	- от англ. Move – движение, т.е. перемещение информации; PUSH	- от англ. Push – поместить, т.е. занести информацию;
    POP	- от англ. POP - выталкивание, т.е. забрать информацию; XCHG	- от англ. Exchange – обмен информацией;
    BSWAP - от англ. Byte Swap – байтовый обмен;
     
    
    MOVSX - от англ. Move with Sign Extended – перемещение информации со знаковым расширением;
    MOVZX - от англ. Move with Zero Extended – перемещение информации с расширением нулем;
    LEA	- от англ. Load Effective Address – загрузить эффективный адрес.
    
    Команда MOV
    Формат команды: MOV П,И
    где 	П – приемник информации. В качестве приемника может использоваться РОН или ячейка памяти;
    И – источник информации. В качестве источника информации могут использоваться РОН, ячейка памяти или константа (непосредственные данные, указанные в самой команде ассемблера).
    
    Команда MOV копирует данные из источника в приемник. Приемник и источник должны быть одинаковой размерности! Нельзя в одной команде MOV пересылать данные между двумя ячейками памяти! При записи в память, т.е., если в качестве приемника указан адрес ячейки памяти, информация размером в Byte (8 бит) будет записана непосредственно в ячейку памяти с адресом, указанным в команде. При записи информации размером в Word (2 байта или 16 бит), будут задействованы две соседние ячейки памяти, начиная с адреса, указанного в команде, причем первым будет записан младший байт информации, а в соседнюю ячейку (в сторону увеличения адресов), старший байт информации. При записи информации размером Integer (2 слова, 4 байта,32 бита), будут задействованы четыре соседних ячейки памяти начиная с адреса, указанного в команде, причем, первым будет записан младший байт младшего слова информации, а в соседние ячейки (в сторону увеличения адресов), соответственно, старший байт младшего слова, младший байт старшего слова и старший байт старшего слова (младшим байтом или словом называют байт или слово с меньшими номерами битов, например, в слове младшим байтом называют байт, который состоит из битов с нулевого по седьмой, а старшим тот, который состоит из битов с восьмого по пятнадцатый).
    
    Примеры:
    MOV AL,10	Занести число 10 в регистр AL. После выполнения
    команды AL=0A.
    MOV BX,$FA	Занести число FA16 (25010) в регистр BX. В данной
    строке примера использован символ «$» перед числом, который является обязательным префиксом для шестнадцатеричного числа. После выполнения команды BX=00FA. Несмотря на то, что в команде указана байтовая константа, компилятор оценит приемник, в качестве которого здесь выступает 16-ти разрядный регистр, и автоматически расширит константу незначащими нулями слева.
     
    
    MOV ECX,EDX	Занести значение регистра EDX в регистр ECX.
    Совершенно очевидно, что EDX сохранит свое значение.
    MOV [EBX],BH	Занести в ячейку памяти (т.к. приемник указан в
    квадратных скобках) с адресом, хранящимся в регистре EBX, один байт (так как источником является 8-ми разрядный регистр) со значением, хранящимся в регистре BH.
    MOV Byte Ptr [ESI], $F0 Занести в ячейку памяти (т.к. приемник указан в
    квадратных скобках) с адресом, хранящимся в регистре ESI, один байт со значением F016 (24010). В данном случае определить размер источника без дополнительных указаний не представляется возможным, так как это может быть и F016, и 00F016, и 000000F016 и любая из этих констант может быть записана в память, заняв, соответственно, одну, две или четыре соседних ячейки памяти. В таких случаях размер данных указывается специальным префиксом, в данном случае Byte Ptr, который четко указывает, что заноситься будет один байт.
    MOV Word Ptr [ECX+EDX*2], $1234 Занести в ячейку памяти с адресом,
    вычисленным по выражению ECX+EDX*2, одно слово со значением 123416 (466010). При этом по адресу ECX+EDX*2 будет занесен байт $34, а по адресу ECX+EDX*2+1 байт $12.
    MOV DWord Ptr [ECX+EBX+$A], $12345678 Занести в ячейку памяти с
    адресом, вычисленным по выражению ECX+EBX+$A, двойное слово со значением 1234567816 (1908874410). При этом по адресу ECX+EBX+$A будет занесен байт $78, по адресу ECX+EBX+$A+1 байт $56, по адресу ECX+EBX+$A+2 байт $34, а по адресу ECX+EBX+$A+3 байт $12.
    
    Команда PUSH
    Формат команды: PUSH	И
    где И – источник информации. В качестве источника информации могут использоваться РОН, ячейка памяти или константа (непосредственные данные, указанные в самой команде ассемблера).
    
    Команда PUSH копирует данные из источника в вершину стека. В качестве источника могут использоваться только 16-ти и 32-ух разрядные данные! Стеком называется область памяти в общем адресном пространстве, которая работает по принципу FILO (First In Last Out – первым вошел последним вышел). Для работы со стеком используются специальные команды, а также стек используется автоматически при вызове подпрограмм. 
    В самом простом случае стек используется для быстрого временного сохранения и восстановления значений РОН. Языки высокого уровня используют стек для передачи параметров в процедуры и функции.
    
    Внимание: В процессорах Intel P6 адрес вершины стека после занесения данных уменьшается.
    
    Примеры:
    PUSH AX		Поместить в стек значение регистра AX.
    PUSH Word Ptr $FA	Поместить в стек значение слова FA16 (25010).
    Таким образом в стек запишется 00FA16.
    
    PUSH DWord Ptr [EBX]	Поместить в стек длинное слово из четырех
    соседних ячеек, первая из которых имеет адрес с номером, хранящимся в EBX.
    
    Команда PUSH имеет модификации:
    PUSHA – занести в стек все 16-ти разрядные РОН в следующем порядке AX,CX,DX,BX,SP,BP,SI,DI;
    PUSHAD – занести в стек все 32-ух разрядные РОН в следующем порядке EAX,ECX,EDX,EBX,ESP,EBP,ESI,EDI;
    
`
  },  
  {
    title: 'Краткие теоретические сведения для Лабораторной работы №2',
    content: `Регистр флагов 
    При	выполнении	некоторых	команд	процессору	необходима дополнительная информация, так же как и после выполнения некоторых
 

команд необходимо сохранить дополнительную информацию о результатах выполнения команды. Чаще всего необходимость в дополнительной информации при выполнении команд возникает при выполнении арифметических команд. Поскольку процессор может оперировать данными определенных размеров (Byte, Word, LongWord), а при выполнении арифметических операций результат может не уместиться в используемый тип данных, то необходимо эту дополнительную информацию сохранять для дальнейшего учета. Местом хранения этой дополнительной информации является регистр флагов EFLAGS. Регистр флагов представляет собой 32- битный регистр специального назначения (РСН), где фиксируется информация о текущем состоянии процессора. Многие их его битов используются при выполнении команд и устанавливаются после выполнения команд. Расположение битов в регистре флагов представлено в таблице 4. Первая строка таблицы содержит номера битов регистра флагов, вторая – их аббревиатуры.
Таблица 4.

31	30	29	28	27	26	25	24	23	22	21	20	19	18	17	16	15	14	13	12	11	10	9	8	7	6	5	4	3	2	1	0
0	0	0	0	0	0	0	0	0	0	ID	VIP	VIF	AC	VM	RF	0	NT	IOPL	OF	DF	IF	TF	SF	ZF	0	AF	0	PF	1	CF

Флаг CF называется флагом переноса (от английского Carry Flag). Флаг переноса устанавливается (становиться равным 1) при переносе (заёме), возникающем при сложении (вычитании). Иначе сбрасывается (становиться равным 0). Может быть установлен и в других случаях в зависимости от выполняемой команды.
Флаг ZF – флаг нулевого результата (Zero Flag). Если результат последней операции равен нулю, то флаг устанавливается, иначе сбрасывается.
Флаг AF – флаг вспомогательного переноса (Auxiliary Carry Flag). Устанавливается при переносе (заёме) из бита 3 (в бит 3) при сложении (вычитании). Используется только для двоично-десятичной арифметики, которая оперирует исключительно младшими байтами.
Флаг SF – флаг знака (Sign Flag). Дублирует старший бит результата, который при использовании дополнительного кода соответствует знаку числа.
Флаг OF – флаг переполнения (Overflow Flag). Сигнализирует о потере старшего бита результата в связи с переполнением разрядной сетки при работе со знаковыми числами. Равен 1, когда:
-	при сложении был перенос из старшего бита, но не было переноса в старший бит;
-	при сложении был перенос в старший бит, но не было переноса из старшего бита;
-	при вычитании был заем в старший бит, но не было заёма из старшегобита; 
-   при вычитании был заем из старшего бита, но не было заёма в старший бит.
 

Флаг PF – флаг четности (Parity Flag). Устанавливается в 1 при наличие четного числа единиц в двоичном представлении младшего байта результата (ЧЕТНОСТЬ НЕ ПО МАТЕМАТИКЕ!)
Флаг DF – флаг направления (Direction Flag). Используется в командах работы со строками (цепочками). При DF=1 регистр(ы) индекса, используемый(ые) в командах работы со строками, увеличивается(ются) на 1 при каждом следующем выполнении команды, при DF=0 - регистр(ы) индекса уменьшается(ются) на 1.
Остальные флаги являются достаточно специфичными и выходят за рамки данного пособия. Их описание можно найти, например, в [2-3].
В Visual Studio обозначения флагов отличается от классического их обозначения. Ниже приведена таблица соответствий названий. 

`
  },
  {
    title: 'Краткие теоретические сведения для Лабораторной работы №4',
    content: `Различают команды, выполняющие логические операции и команды манипулирования битами. Команды выполняют операции с битами байта, слова или двойного слова, поэтому еще называются побитовыми (поразрядными) командами.
    Теоретической базой для логических операций является булева алгебра, которая впервые была исследована Дж. Булем (1815-1864). Она базируется на высказываниях. Высказывание – это законченное предложение, о котором можно определенно сказать, что его содержание истинно или ложно. Операции булевой алгебры определены для таких высказываний. Всевозможные наборы входных значений и значений булевой функции на этих наборах входных значений составляют таблицу истинности данной булевой функции.
    
    К	командам,	выполняющим	логические	операции,	и	командам манипулирования битами относятся:
    AND	– Операция логического умножения «И»;
    OR		– Операция логического сложения «ИЛИ»; XOR	(eXclusive OR)	– Операция «исключающее ИЛИ»;
    NOT		– Операция двоичной инверсии; SAL	(Shift Arithmetic Left) – Арифметический сдвиг влево; SAR	(Shift Arithmetic Right) – Арифметический сдвиг вправо; SHL	(SHift Left)	– Сдвиг влево;
    SHR	(SHift Right)	– Сдвиг вправо;
    SHLD	(SHift Left Double)	– Сдвиг влево двойной точности; SHRD	(SHift Right Double)	– Сдвиг вправо двойной точности; ROL	(ROtate Left)	– Циклический сдвиг влево;
    ROR	(ROtate Right)	– Циклический сдвиг вправо;
    RLC	(Rotate through Carry Left) – Циклический сдвиг влево через флаг
    CF;
    RRC	(Rotate through Carry Right) – Циклический сдвиг вправо через
    флаг CF;
    BT	(Bit Test)	– Переместить бит для тестирования; BTS	(Bit Test and Set)	– Протестировать бит и установить его;
     
    
    BTC	(Bit Test and Complement) – Протестировать бит и инвертировать
    его;
    BTR	(Bit Transfer and Reset) – Протестировать бит и сбросить его;
    BSF	(Bit Scan Forward)	– Сканировать биты в прямом
    направлении;
    BSR	(Bit Scan Reverse)	– Сканировать биты в обратном
    направлении;
    TEST		– Протестировать операнд;
    CLC	(Clear CF)	– Очистить флаг CF;
    CLD	(Clear DF)	– Очистить флаг DF;
    CMC	(Complement CF)	– Инвертировать флаг CF;
    STC	(Set CF)	– Установить флаг CF;
    STD	(Set DF)	– Установить флаг DF;
    
    Команды AND,OR,XOR Формат команды: AND		П,И Формат команды: OR	П,И
    Формат команды: XOR	П,И
    Команды выполняют побитовые логические операции над приемником П, в качестве которого могут выступать регистр или ячейка памяти, и источником И, в качестве которого могут выступать регистр, ячейка памяти или константа. Источник и приемник не могут быть одновременно ячейками памяти. Результат операции помещается в приемник П. Таблицы истинности для каждой функции представлены в таблице 7.
    таблица 7.
        AND				OR				XOR			NOT
    Логическое умножение		Логическое сложение		Логическое
    исключающее ИЛИ		Логическое отрицание
    X	Y	Вых.		X	Y	Вых.		X	Y	Вых.		Х	Вых.
    0	0	0		0	0	0		0	0	0		0	1
    0	1	0		0	1	1		0	1	1		1	0
    1	0	0		1	0	1		1	0	1		
    1	1	1		1	1	1		1	1	0		
    
    Один из распространенных вариантов применения команды AND для выполнения операции маскирования или наложения маски. Как и в случае с обычной, театральной, маской, сквозь нее видно только там, где есть прорези. Если нам необходимо, чтобы в каком-либо операнде одни значения битов под конкретными номерами сохранились, а другие нет (обнулились), то мы выполним команду AND, в которой в качестве второго операнда будет такое значение, в котором на месте битов, значения которых надо сохранить, будут стоять «1», а во всех остальных нули.
    Команду OR чаще всего используют для выборочной установки отдельных битов без изменения значений остальных битов. Это достигается за счет того, что команда OR выполняет логическое сложение, а значит, сложение
     
    
    с нулем не меняет значение бита, а сложение с «1» установит бит, вне зависимости от его предыдущего значения.
    Команда XOR используется в разных логических операциях. Иногда, чаще используют две ее особенности. Если выполнить команду XOR, в которой приемник и источник равны, то результатом команды будет нуль. Вторая особенность, если дважды выполнить команду XOR с одним и тем же источником, то приемник станет равным своему первоначальному значению.
    Флаги, которые устанавливаются в результате этой команды, приведены в таблице 8.
    

`
  },

];


const TopicsList = () => {
  const [currentIndex, setCurrentIndex] = useState(0);
  
  const selectedTopic = useMemo(() => topics[currentIndex], [currentIndex]);

  const handleNextTopic = useCallback(() => {
    setCurrentIndex((prevIndex) => (prevIndex + 1) % topics.length);
  }, []);

  const handleTopicClick = useCallback((index) => {
    setCurrentIndex(index);
  }, []);

  return (
    <div className="topics-container">
      <div className="topic-viewer-container">
        <button className="next-topic-button" onClick={handleNextTopic}>Следующая тема</button>
        <TopicViewer topic={selectedTopic} />
      </div>
      <div className="topics-list">
        {topics.map((topic, index) => (
          <button
            key={index}
            onClick={() => handleTopicClick(index)}
            className={
              `topic-button${index === currentIndex ? ' active' : ''}`
            }
          >
            {topic.title}
          </button>
        ))}
      </div>
    </div>
  );
};

export default TopicsList;

