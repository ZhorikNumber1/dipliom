import React, { useState, useCallback, useMemo } from 'react';
import TopicViewer from "./TopicViewer"
import './TopicsList.css';


const topics = [
  {
    title: 'Работа с числами',
    content: `Работа с числами в ассемблере включает выполнение различных арифметических операций, таких как сложение, вычитание, умножение и деление. Эти операции выполняются с использованием специальных машинных инструкций и регистров процессора.
      Основные арифметические операции:
      Сложение (ADD): Команда ADD используется для сложения двух чисел. Она складывает значение операнда с содержимым регистра и сохраняет результат в регистре.
      Вычитание (SUB): Команда SUB используется для вычитания одного числа из другого. Она вычитает значение операнда из содержимого регистра и сохраняет результат в регистре.
      Пример:
      MOV AX, 4  ; Переместить значение 4 в регистр AX
      ADD AX, 3  ; Добавить значение 3 к содержимому регистра AX, в результате AX будет содержать 7
      SUB AX, 1  ; Вычесть 1 из содержимого регистра AX, в результате AX будет содержать 6`
  },
  {
    title: 'Работа процессора',
    content: `В этом разделе мы рассмотрим ключевые компоненты, составляющие внутреннюю архитектуру процессоров, таких как те, что разрабатываются Intel. Эти элементы играют критическую роль в выполнении вычислительных задач и обеспечивают высокую производительность современных компьютеров.

    1. Арифметико-Логическое Устройство (ALU)
       - ALU является центральным компонентом процессора, ответственным за выполнение всех арифметических и логических операций.
       - Основные функции ALU включают сложение, вычитание, умножение, деление, а также выполнение логических операций, таких как AND, OR, XOR и NOT.
       - ALU принимает операнды (входные данные) из регистров, выполняет вычисления и возвращает результат обратно в регистры или в память.`
  },
  {
    title: 'Синтаксис Ассемблера',
    content: `Ассемблер является языком низкого уровня, который напрямую соответствует инструкциям процессора. Основные концепции ассемблера включают:
  Мнемоники
  Мнемоники (или мнемонические коды) — это символические имена для машинных инструкций, которые облегчают чтение и написание кода. Вместо того чтобы писать длинные и сложные бинарные или шестнадцатеричные коды, программисты используют понятные обозначения.
    
  Пример:
  MOV AX, 1    ; Переместить значение 1 в регистр AX
  ADD AX, 2    ; Добавить 2 к значению в регистре AX
  SUB AX, 1    ; Вычесть 1 из значения в регистре AX
    
    В этом примере MOV, ADD и SUB являются мнемониками, которые представляют машинные команды для перемещения данных и выполнения арифметических операций[5].
    
    Регистр
    Регистры — это небольшие, высокоскоростные хранилища данных в процессоре. Программы на ассемблере работают с регистрами процессора для выполнения различных операций.
    Основные регистры в архитектуре x86:
    AX (Accumulator): используется для арифметических операций и ввода/вывода.
    BX (Base): часто используется для индексирования.
    CX (Count): используется для счетчиков в циклах.
    DX (Data): используется для ввода/вывода и некоторых операций умножения и деления.
    Пример:
    MOV AX, 5    ; Переместить значение 5 в регистр AX
    MOV BX, AX   ; Скопировать значение из регистра AX в регистр BX
    В этом примере значение 5 сначала загружается в регистр AX, а затем копируется в регистр BX[6].
    
    Адресация
    Ассемблер предоставляет различные методы адресации, которые определяют, как операнды выбираются для команд. Основные методы адресации включают:
    
    Непосредственная адресация: значение операнда указывается непосредственно.
    Регистровая адресация: операнд находится в регистре.
    Косвенная адресация: операнд находится по адресу, который содержится в регистре.
    Пример:
    
    MOV AX, 10       ; Непосредственная адресация: переместить значение 10 в AX
    MOV BX, AX       ; Регистровая адресация: переместить значение из AX в BX
    MOV CX, [BX]     ; Косвенная адресация: переместить значение из памяти по адресу BX в CX
    В этом примере используются разные методы адресации для работы с регистрами и памятью.
    
    Директивы
    Директивы в ассемблере управляют процессом сборки программы. Они не являются командами для процессора, но дают указания ассемблеру, как обрабатывать код.
    
    
    Основные директивы:
    
    SEGMENT: определяет начало сегмента.
    ENDS: указывает конец сегмента.
    DB (Define Byte): определяет байт данных.
    Пример:
    
    DATA SEGMENT
           NUM1 DB 10      ; Определить байт данных со значением 10
            NUM2 DB 20      ; Определить байт данных со значением 20
    DATA ENDS
    
    CODE SEGMENT
            ASSUME CS:CODE, DS:DATA
    START:
           MOV AX, DATA
           MOV DS, AX
            MOV AL, NUM1    ; Переместить значение NUM1 в AL
           MOV BL, NUM2    ; Переместить значение NUM2 в BL
           ADD AL, BL      ; Сложить значения в AL и BL
            MOV NUM1, AL    ; Сохранить результат обратно в NUM1
            INT 20H         ; Завершить программу
    CODE ENDS
    END START
    
    В этом примере используются директивы для определения сегментов данных и кода, а также для управления сборкой программы[8].
    
    
    
    
    Комментарии
    Комментарии в ассемблере используются для объяснения кода и улучшения его читаемости. Комментарии начинаются с символа “;” и игнорируются ассемблером при сборке программы.
    
    Пример:
    MOV AX, 1    ; Переместить значение 1 в регистр AX
    ADD AX, 2    ; Добавить 2 к значению в регистре AX
    SUB AX, 1    ; Вычесть 1 из значения в регистре AX
    В этом примере комментарии объясняют каждую команду, делая код более понятным для других программистов[9].
    `
  }
];


const TopicsList = () => {
  const [currentIndex, setCurrentIndex] = useState(0);
  
  const selectedTopic = useMemo(() => topics[currentIndex], [currentIndex]);

  const handleNextTopic = useCallback(() => {
    setCurrentIndex((prevIndex) => (prevIndex + 1) % topics.length);
  }, []);

  const handleTopicClick = useCallback((index) => {
    setCurrentIndex(index);
  }, []);

  return (
    <div className="topics-container">
      <div className="topic-viewer-container">
        <button className="next-topic-button" onClick={handleNextTopic}>Следующая тема</button>
        <TopicViewer topic={selectedTopic} />
      </div>
      <div className="topics-list">
        {topics.map((topic, index) => (
          <button
            key={index}
            onClick={() => handleTopicClick(index)}
            className={
              `topic-button${index === currentIndex ? ' active' : ''}`
            }
          >
            {topic.title}
          </button>
        ))}
      </div>
    </div>
  );
};

export default TopicsList;

